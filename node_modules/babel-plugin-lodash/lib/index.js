'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var

  /*----------------------------------------------------------------------------*/

  types = _ref.types;


  var identifiers = {
    'PLACEHOLDER': types.identifier('placeholder'),
    'UNDEFINED': types.identifier('undefined')
  };

  /**
   * Used to track variables built during the AST pass. We instantiate these in
   * the `Program` visitor in order to support running the plugin in watch mode
   * or on multiple files.
   *
   * @type Store
   */
  var store = new _Store2.default(_mapping2.default.ids.concat('lodash/fp'));

  function getCallee(path) {
    var result = void 0;
    var parent = path.parent;

    // Trace curried calls to their origin, e.g. `fp.partial(func)([fp, 2])(1)`.

    while (types.isCallExpression(parent)) {
      parent = result = parent.callee;
    }
    return result;
  }

  function isDefaultMember(name) {
    return !!store.getStoreBy('default', name);
  }

  function isIdentifier(node, path) {
    if (types.isIdentifier(node)) {
      var parent = _lodash2.default.get(path.scope.getAllBindings(), [node.name, 'path', 'parent']);
      return isImportDeclaration(parent);
    }
    return false;
  }

  function isImportDeclaration(node) {
    return types.isImportDeclaration(node) && store.has(node.source.value);
  }

  var replaceNode = _lodash2.default.curry(function (key, path) {
    var object = path.node;
    var node = object[key];
    if (isIdentifier(node, path)) {
      object[key] = store.getValueBy('member', node.name);
    }
  });

  var replaceNodes = _lodash2.default.curry(function (props, path) {
    _lodash2.default.each(props, function (key) {
      return replaceNode(key, path);
    });
  });

  var replaceNodeList = _lodash2.default.curry(function (key, callee, path) {
    var nodes = path.node[key];
    var placeholder = callee ? types.memberExpression(callee, identifiers.PLACEHOLDER) : identifiers.UNDEFINED;

    _lodash2.default.each(nodes, function (node, index) {
      if (isIdentifier(node, path)) {
        // Assume default members are placeholders.
        nodes[index] = isDefaultMember(node.name) ? placeholder : store.getValueBy('member', node.name);
      }
    });
  });

  var replaceElements = replaceNodeList('elements');
  var replaceArguments = replaceNodeList('arguments');

  /*--------------------------------------------------------------------------*/

  var visitor = {
    Program: function Program(path, state) {
      var _$assign = _lodash2.default.assign(_mapping2.default, (0, _config2.default)(state.opts));

      var ids = _$assign.ids;

      if (_lodash2.default.isEmpty(ids)) {
        throw new Error('Cannot find Lodash module');
      }
      _lodash2.default.each(ids, function (id) {
        return store.set(id);
      });

      // Clear tracked Lodash method imports and variables.
      _importModule2.default.cache.clear();
      store.clear();
    },
    ImportDeclaration: function ImportDeclaration(path) {
      var node = path.node;

      var pkgStore = store.get(node.source.value);

      if (!pkgStore) {
        return;
      }
      var defaultMap = pkgStore.get('default');
      var identifierMap = pkgStore.get('identifier');
      var memberMap = pkgStore.get('member');

      // Remove the original import node.
      path.remove();

      // Track all the Lodash default and specifier imports in the source.
      _lodash2.default.each(node.specifiers, function (spec) {
        var local = spec.local;

        if (types.isImportSpecifier(spec)) {
          // Replace member import, e.g. `import { map } from 'lodash'`, with
          // cherry-picked default import, e.g. `import _map from 'lodash/map'`.
          var identifier = (0, _importModule2.default)(pkgStore, spec.imported.name, path.hub.file);

          identifierMap.set(identifier.name, local.name);
          memberMap.set(identifier.name, identifier);
          memberMap.set(local.name, identifier);
        } else {
          // Cache original default member name, e.g. `_` of `import _ from 'lodash'`.
          defaultMap.set(local.name, true);
          memberMap.set(local.name, identifiers.UNDEFINED);
        }
      });
    },
    MemberExpression: function MemberExpression(path) {
      var node = path.node;
      var object = node.object;
      var property = node.property;


      if (!isIdentifier(object, path)) {
        return;
      }
      var pkgStore = store.getStoreBy('default', object.name);
      if (pkgStore) {
        if (property.name == 'chain') {
          throw new Error(CHAIN_ERROR);
        }
        // Replace `_.map` with `_map`.
        path.replaceWith((0, _importModule2.default)(pkgStore, property.name, path.hub.file));
      } else {
        // Allow things like `_bind.placeholder = {}`.
        node.object = store.getValueBy('member', object.name);
      }
    },
    CallExpression: function CallExpression(path) {
      var node = path.node;
      var callee = node.callee;


      if (isIdentifier(callee, path)) {
        if (isDefaultMember(callee.name)) {
          // Detect chain sequences by `_()`.
          throw new Error(CHAIN_ERROR);
        }
        // Replace `map()` with `_map()`.
        node.callee = store.getValueBy('member', callee.name);
      } else if (types.isBindExpression(callee)) {
        visitor.CallExpression(path.get('callee'));
      } else if (types.isMemberExpression(callee)) {
        visitor.MemberExpression(path.get('callee'));
      }
      // Replace lodash references in arguments, e.g. `_.flow(_.map, _.head)`.
      replaceArguments(node.callee, path);
    },
    ArrayExpression: function ArrayExpression(path) {
      // Detect lodash callees to use as argument placeholders.
      var callee = getCallee(path);
      var name = callee ? store.getValueBy('identifier', callee.name) || callee.name : '';
      replaceElements(store.getValueBy('member', name), path);
    },
    ExportNamedDeclaration: function ExportNamedDeclaration(path) {
      var node = path.node;

      var pkgPath = _lodash2.default.get(node, 'source.value');
      var pkgStore = store.get(pkgPath);

      if (pkgStore) {
        node.source = null;
      }
      _lodash2.default.each(node.specifiers, function (spec) {
        var local = spec.local;

        if (pkgStore) {
          spec.local = (0, _importModule2.default)(pkgStore, local.name, path.hub.file);
        } else if (isIdentifier(spec.local, path)) {
          spec.local = store.getValueBy('member', local.name);
        }
      });
    },


    // Various other (less common) ways to use a lodash specifier. This code
    // doesn't apply to uses on a lodash object, only directly imported specifiers.
    'Property': replaceNode('value'),
    'VariableDeclarator': replaceNode('init'),

    // Allow things like `o.a = _.noop`.
    'AssignmentExpression': replaceNode('right'),

    // Allow things like `var x = y || _.noop`.
    'LogicalExpression': replaceNodes(['left', 'right']),

    // Allow things like `var x = y ? _.identity : _.noop`.
    'ConditionalExpression': replaceNodes(['test', 'consequent', 'alternate'])
  };

  return { visitor: visitor };
};

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _importModule = require('./importModule');

var _importModule2 = _interopRequireDefault(_importModule);

var _mapping = require('./mapping');

var _mapping2 = _interopRequireDefault(_mapping);

var _Store = require('./Store');

var _Store2 = _interopRequireDefault(_Store);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** The error message used when chain sequences are detected. */
var CHAIN_ERROR = ['Lodash chain sequences are not supported by babel-plugin-lodash.', 'Consider substituting chain sequences with composition patterns.', 'See https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba'].join('\n');;
module.exports = exports['default'];